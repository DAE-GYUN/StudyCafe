
/*
This file has been generated by UsingEntityFramework on 2020-11-25 오후 3:27:09.
You may not need to modify this file.
*/

#region
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Data.Entity;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
#endregion

namespace StudyCafe.Data
{
	#region Entities

    #region IEntity
    public partial interface IEntity
    {
    }
    #endregion

	#region Untyped Entity
	/// <summary>
	///   모든 엔터티 클래스의 부모 클래스
	/// </summary>
	public abstract partial class UntypedEntity : IEntity
	{
		/// <summary>
		///   부가정보를 저장하기 위한 object 객체
		/// </summary>
		[NotMapped]
		public object EntityTag { get; set; }

		/// <summary>
		///   모든 속성의 값을 초기화한다.string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear()
		{
			Clear(string.Empty, DateTime.Today);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(DateTime defaultDateTime)
		{
			Clear(string.Empty, defaultDateTime);
		}

		/// <summary>
		///   모든 속성의 값을 초기화한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString"> 기본 string 값 </param>
		/// <param name="defaultDateTime"> 기본 DateTime 값 </param>
		/// <returns> 생성된 엔터티 </returns>
		public void Clear(string defaultString, DateTime defaultDateTime)
		{
			Type type = GetType();
			PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);

			foreach (PropertyInfo propertyInfo in propertyInfoArray)
			{
				if (propertyInfo.CanWrite == false)
					continue;

				if (propertyInfo.PropertyType == typeof (string))
					propertyInfo.SetValue(this, defaultString, null);

				else if (propertyInfo.PropertyType == typeof (DateTime))
					propertyInfo.SetValue(this, defaultDateTime, null);
			}
		}

		/// <summary>
		///   기본키 값들을 구분자(":")로 연결하여 반환한다.
		/// </summary>
		/// <returns> </returns>
		public abstract string PrimaryKeyValues {get;}

		/// <summary>
		/// 엔터티를 대표하는 문자열을 구한다.
		/// </summary>
		public abstract string EntityText { get; }

		/// <summary>
		///   엔터티의 이름을 구한다.
		/// </summary>
		public abstract string GetEntityTypeName();

		partial void IsLogWritable(ref bool? logWritable);

		public virtual bool LogWritable
		{
			get
			{
			bool? logWritable = null;
			IsLogWritable(ref logWritable);

			if (logWritable.HasValue)
				return logWritable.Value;

			return false;
			}
		}

		/// <summary>
		///   EntityLog에 찍힐 문자열을 구한다. Code로 끝나는 코드 프로퍼티의 경우 대응하는 문자열 프로퍼티의 값도 추가한다.
		///   주의) EntityLog 테이블의 설계 상 최대 2000자 까지만 저장할 수 있음.
		/// </summary>
		/// <returns> </returns>
		public virtual string ToEntityLog()
		{
			const int MaxLength = 2000; // 최대 2000자 까지만 저장.

			Type type = GetType();

			var propertyInfoes = type.GetProperties();

			StringBuilder builder = new StringBuilder(ToString());

			builder.AppendLine();
			foreach (var propertyInfo in propertyInfoes)
			{
				if (propertyInfo.PropertyType != typeof (int))
					continue;

				if (propertyInfo.Name.EndsWith("Code") == false)
					continue;

				string textPropertyName = propertyInfo.Name.Substring(0, propertyInfo.Name.Length - 4) + "Text";
				string textValue = GetTextFromCodeProperty(this, type, textPropertyName);

				if (textValue != null)
					builder.AppendFormat("[{0}] {1}{2}", textPropertyName, textValue, Environment.NewLine);
			}

			if (builder.Length > MaxLength)
				return builder.ToString(0, MaxLength);
			else
				return builder.ToString();
		}

		private static string GetTextFromCodeProperty(object entity, Type objectType, string textPropertyName)
		{
			var propertyInfo = objectType.GetProperty(textPropertyName);
			object propertyValue = propertyInfo.GetValue(entity, null);

			if (propertyValue is string)
				return (string) propertyValue;
			else
				return null;
		}
	}
	#endregion

	#region Entity<T>
	/// <summary>
	/// 모든 엔터티 클래스의 형이 지정된 부모 클래스
	/// </summary>
	/// <typeparam name="T">엔터티 클래스의 형식</typeparam>
	public abstract partial class Entity<T> : UntypedEntity, IEditableObject where T : class, new()
	{
		/// <summary>
		/// 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public abstract T Clone();

		#region Implementation of IEditableObject

		protected T _clone = null;

		/// <summary>
		/// IEditableObject.BeginEdit 구현
		/// </summary>
		public void BeginEdit()
		{
			if (_clone == null)
				_clone = Clone();
		}

		/// <summary>
		/// IEditableObject.EndEdit 구현
		/// </summary>
		public void EndEdit()
		{
			_clone = null;
		}

		public abstract void CancelEdit();

	#endregion
	}

	#endregion

		#region Invoice
    /// <summary>
	/// Invoice 엔터티
	/// </summary>
    public partial class Invoice : Entity<Invoice>, IEntity
	{
		public const string EntityTypeName = "Invoice";

		public static void Copy(Invoice source, Invoice target)
		{
						target.InvoiceID = source.InvoiceID;		
			target.InvoiceDatetime = source.InvoiceDatetime;		
			target.InvoicePlace = source.InvoicePlace;		
			target.UserID = source.UserID;
		}

		/// <summary>
		/// Invoice 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Invoice Clone()
		{
			var clone = new Invoice();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Invoice 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[InvoiceID]" + InvoiceID + ", " + "[InvoiceDatetime]" + InvoiceDatetime + ", " + "[InvoicePlace]" + InvoicePlace + ", " + "[UserID]" + UserID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", InvoiceID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Invoice 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum InvoiceColumn
	{
				InvoiceID,
		InvoiceDatetime,
		InvoicePlace,
		UserID
	}

	
	/// <summary>
	/// Invoice 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Invoice> 구현)
	/// </summary>
	public class InvoiceEqualityComparer : IEqualityComparer<Invoice>
	{
		public bool Equals(Invoice x, Invoice y)
		{
			return x.InvoiceID == y.InvoiceID;
		}

		public int GetHashCode(Invoice obj)
		{
			return obj.InvoiceID.GetHashCode();
		}
	}
	
	#endregion
	#region InvoiceLine
    /// <summary>
	/// InvoiceLine 엔터티
	/// </summary>
    public partial class InvoiceLine : Entity<InvoiceLine>, IEntity
	{
		public const string EntityTypeName = "InvoiceLine";

		public static void Copy(InvoiceLine source, InvoiceLine target)
		{
						target.InvoiceID = source.InvoiceID;		
			target.ItemID = source.ItemID;		
			target.ItemPrice = source.ItemPrice;		
			target.NumberOfItem = source.NumberOfItem;
		}

		/// <summary>
		/// InvoiceLine 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override InvoiceLine Clone()
		{
			var clone = new InvoiceLine();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// InvoiceLine 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[InvoiceID]" + InvoiceID + ", " + "[ItemID]" + ItemID + ", " + "[ItemPrice]" + ItemPrice + ", " + "[NumberOfItem]" + NumberOfItem;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", InvoiceID, ItemID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// InvoiceLine 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum InvoiceLineColumn
	{
				InvoiceID,
		ItemID,
		ItemPrice,
		NumberOfItem
	}

	
	/// <summary>
	/// InvoiceLine 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<InvoiceLine> 구현)
	/// </summary>
	public class InvoiceLineEqualityComparer : IEqualityComparer<InvoiceLine>
	{
		public bool Equals(InvoiceLine x, InvoiceLine y)
		{
			return x.InvoiceID == y.InvoiceID && x.ItemID == y.ItemID;
		}

		public int GetHashCode(InvoiceLine obj)
		{
			return obj.InvoiceID.GetHashCode() ^ obj.ItemID.GetHashCode();
		}
	}
	
	#endregion
	#region Item
    /// <summary>
	/// Item 엔터티
	/// </summary>
    public partial class Item : Entity<Item>, IEntity
	{
		public const string EntityTypeName = "Item";

		public static void Copy(Item source, Item target)
		{
						target.ItemID = source.ItemID;		
			target.Kinds = source.Kinds;		
			target.Name = source.Name;		
			target.Price = source.Price;		
			target.Time = source.Time;
		}

		/// <summary>
		/// Item 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Item Clone()
		{
			var clone = new Item();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Item 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[ItemID]" + ItemID + ", " + "[Kinds]" + Kinds + ", " + "[Name]" + Name + ", " + "[Price]" + Price + ", " + "[Time]" + Time;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", ItemID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Item 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum ItemColumn
	{
				ItemID,
		Kinds,
		Name,
		Price,
		Time
	}

	
	/// <summary>
	/// Item 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Item> 구현)
	/// </summary>
	public class ItemEqualityComparer : IEqualityComparer<Item>
	{
		public bool Equals(Item x, Item y)
		{
			return x.ItemID == y.ItemID;
		}

		public int GetHashCode(Item obj)
		{
			return obj.ItemID.GetHashCode();
		}
	}
	
	#endregion
	#region Locker
    /// <summary>
	/// Locker 엔터티
	/// </summary>
    public partial class Locker : Entity<Locker>, IEntity
	{
		public const string EntityTypeName = "Locker";

		public static void Copy(Locker source, Locker target)
		{
						target.LockerID = source.LockerID;		
			target.Name = source.Name;		
			target.UserID = source.UserID;
		}

		/// <summary>
		/// Locker 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Locker Clone()
		{
			var clone = new Locker();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Locker 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[LockerID]" + LockerID + ", " + "[Name]" + Name + ", " + "[UserID]" + UserID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", LockerID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Locker 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum LockerColumn
	{
				LockerID,
		Name,
		UserID
	}

	
	/// <summary>
	/// Locker 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Locker> 구현)
	/// </summary>
	public class LockerEqualityComparer : IEqualityComparer<Locker>
	{
		public bool Equals(Locker x, Locker y)
		{
			return x.LockerID == y.LockerID;
		}

		public int GetHashCode(Locker obj)
		{
			return obj.LockerID.GetHashCode();
		}
	}
	
	#endregion
	#region Log
    /// <summary>
	/// Log 엔터티
	/// </summary>
    public partial class Log : Entity<Log>, IEntity
	{
		public const string EntityTypeName = "Log";

		public static void Copy(Log source, Log target)
		{
						target.LogID = source.LogID;		
			target.Contents = source.Contents;		
			target.date = source.date;		
			target.UserID = source.UserID;
		}

		/// <summary>
		/// Log 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Log Clone()
		{
			var clone = new Log();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Log 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[LogID]" + LogID + ", " + "[Contents]" + Contents + ", " + "[date]" + date + ", " + "[UserID]" + UserID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", LogID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Log 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum LogColumn
	{
				LogID,
		Contents,
		date,
		UserID
	}

	
	/// <summary>
	/// Log 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Log> 구현)
	/// </summary>
	public class LogEqualityComparer : IEqualityComparer<Log>
	{
		public bool Equals(Log x, Log y)
		{
			return x.LogID == y.LogID;
		}

		public int GetHashCode(Log obj)
		{
			return obj.LogID.GetHashCode();
		}
	}
	
	#endregion
	#region Report
    /// <summary>
	/// Report 엔터티
	/// </summary>
    public partial class Report : Entity<Report>, IEntity
	{
		public const string EntityTypeName = "Report";

		public static void Copy(Report source, Report target)
		{
						target.ReportID = source.ReportID;		
			target.Contents = source.Contents;		
			target.Title = source.Title;		
			target.UserID = source.UserID;
		}

		/// <summary>
		/// Report 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Report Clone()
		{
			var clone = new Report();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Report 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[ReportID]" + ReportID + ", " + "[Contents]" + Contents + ", " + "[Title]" + Title + ", " + "[UserID]" + UserID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", ReportID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Report 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum ReportColumn
	{
				ReportID,
		Contents,
		Title,
		UserID
	}

	
	/// <summary>
	/// Report 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Report> 구현)
	/// </summary>
	public class ReportEqualityComparer : IEqualityComparer<Report>
	{
		public bool Equals(Report x, Report y)
		{
			return x.ReportID == y.ReportID;
		}

		public int GetHashCode(Report obj)
		{
			return obj.ReportID.GetHashCode();
		}
	}
	
	#endregion
	#region Seat
    /// <summary>
	/// Seat 엔터티
	/// </summary>
    public partial class Seat : Entity<Seat>, IEntity
	{
		public const string EntityTypeName = "Seat";

		public static void Copy(Seat source, Seat target)
		{
						target.SeatsID = source.SeatsID;		
			target.Name = source.Name;		
			target.UserID = source.UserID;
		}

		/// <summary>
		/// Seat 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override Seat Clone()
		{
			var clone = new Seat();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// Seat 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[SeatsID]" + SeatsID + ", " + "[Name]" + Name + ", " + "[UserID]" + UserID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", SeatsID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// Seat 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum SeatColumn
	{
				SeatsID,
		Name,
		UserID
	}

	
	/// <summary>
	/// Seat 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<Seat> 구현)
	/// </summary>
	public class SeatEqualityComparer : IEqualityComparer<Seat>
	{
		public bool Equals(Seat x, Seat y)
		{
			return x.SeatsID == y.SeatsID;
		}

		public int GetHashCode(Seat obj)
		{
			return obj.SeatsID.GetHashCode();
		}
	}
	
	#endregion
	#region StudyRoom
    /// <summary>
	/// StudyRoom 엔터티
	/// </summary>
    public partial class StudyRoom : Entity<StudyRoom>, IEntity
	{
		public const string EntityTypeName = "StudyRoom";

		public static void Copy(StudyRoom source, StudyRoom target)
		{
						target.StudyRoomID = source.StudyRoomID;		
			target.Name = source.Name;		
			target.UserID = source.UserID;
		}

		/// <summary>
		/// StudyRoom 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override StudyRoom Clone()
		{
			var clone = new StudyRoom();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// StudyRoom 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[StudyRoomID]" + StudyRoomID + ", " + "[Name]" + Name + ", " + "[UserID]" + UserID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", StudyRoomID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// StudyRoom 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum StudyRoomColumn
	{
				StudyRoomID,
		Name,
		UserID
	}

	
	/// <summary>
	/// StudyRoom 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<StudyRoom> 구현)
	/// </summary>
	public class StudyRoomEqualityComparer : IEqualityComparer<StudyRoom>
	{
		public bool Equals(StudyRoom x, StudyRoom y)
		{
			return x.StudyRoomID == y.StudyRoomID;
		}

		public int GetHashCode(StudyRoom obj)
		{
			return obj.StudyRoomID.GetHashCode();
		}
	}
	
	#endregion
	#region User
    /// <summary>
	/// User 엔터티
	/// </summary>
    public partial class User : Entity<User>, IEntity
	{
		public const string EntityTypeName = "User";

		public static void Copy(User source, User target)
		{
						target.UserID = source.UserID;		
			target.Admin = source.Admin;		
			target.LockerID = source.LockerID;		
			target.Name = source.Name;		
			target.PhoneNumber = source.PhoneNumber;		
			target.RemainLockerTime = source.RemainLockerTime;		
			target.RemainSeatTime = source.RemainSeatTime;		
			target.RemainStudyRoomTime = source.RemainStudyRoomTime;		
			target.SeatsID = source.SeatsID;		
			target.StudyRoomID = source.StudyRoomID;
		}

		/// <summary>
		/// User 객체를 복사한다.
		/// </summary>
		/// <returns></returns>
		public override User Clone()
		{
			var clone = new User();

			Copy(this, clone);

			return clone;
		}

		partial void GetEntityTextCore(ref string value);

		/// <summary>
		/// User 객체를 대표하는 이름을 구한다.
		/// </summary>
		/// <returns></returns>
		public override string EntityText
		{
			get 
			{ 
				string value = null;
				GetEntityTextCore(ref value);

				if (value != null)
					return value;

				return PrimaryKeyValues; 
			}
		}

		partial void ToStringCore(ref string value);

		public override string ToString()
		{
			string value = null;
			ToStringCore(ref value);

			if (value != null)
				return value;

			return "[UserID]" + UserID + ", " + "[Admin]" + Admin + ", " + "[LockerID]" + LockerID + ", " + "[Name]" + Name + ", " + "[PhoneNumber]" + PhoneNumber + ", " + "[RemainLockerTime]" + RemainLockerTime + ", " + "[RemainSeatTime]" + RemainSeatTime + ", " + "[RemainStudyRoomTime]" + RemainStudyRoomTime + ", " + "[SeatsID]" + SeatsID + ", " + "[StudyRoomID]" + StudyRoomID;
		}

		/// <summary>
		/// IEditableObject.CancelEdit 구현
		/// </summary>
		public override void CancelEdit()
		{
			if (_clone != null)
				Copy(_clone, this);
		}

		public override string PrimaryKeyValues
		{
			get { return string.Join(":", UserID); }
		}

		public override string GetEntityTypeName()
		{
			return EntityTypeName;
		}
	}

	/// <summary>
	/// User 엔터티의 컬럼 이름을 멤버로 가지고 있는 열거형
	/// </summary>
	public enum UserColumn
	{
				UserID,
		Admin,
		LockerID,
		Name,
		PhoneNumber,
		RemainLockerTime,
		RemainSeatTime,
		RemainStudyRoomTime,
		SeatsID,
		StudyRoomID
	}

	
	/// <summary>
	/// User 엔터티의 기본키를 조건으로 하여 동등성을 비교하는 비교자 (IEqualityComparer<User> 구현)
	/// </summary>
	public class UserEqualityComparer : IEqualityComparer<User>
	{
		public bool Equals(User x, User y)
		{
			return x.UserID == y.UserID;
		}

		public int GetHashCode(User obj)
		{
			return obj.UserID.GetHashCode();
		}
	}
	
	#endregion

	#endregion

	#region PropertyChangedEventArgs
	/// <summary>
	/// 속성 값이 변경된 후 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	internal class PropertyChangedEventArgs<T> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경된 엔티티
		/// </summary>
		public T Entity { get; set; }

		public PropertyChangedEventArgs(T entity)
		{
			Entity = entity;
		}
	}

	/// <summary>
	/// 속성 값이 변경되기 전 발생하는 이벤트의 매개변수 클래스
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <typeparam name="K"></typeparam>
	internal class PropertyChangingEventArgs<T, K> : EventArgs where T : Entity<T>, new()
	{
		/// <summary>
		/// 속성 값이 변경될 엔티티
		/// </summary>
		public T Entity { get; set; }

		/// <summary>
		/// 새로 변경 될 속성 값
		/// </summary>
		public K Value { get; set; }

		public PropertyChangingEventArgs(T entity, K value)
		{
			Entity = entity;
			Value = value;
		}
	}
	#endregion

	#region Data
	#region EntityData<T>
	[Data]
	public abstract partial class EntityData<T> where T : Entity<T>, new()
	{
		internal EntityData() { }

		#region Create
		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 DateTime.Today 값으로 채운다.
		/// </summary>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create()
		{
			return Create(string.Empty, DateTime.Today);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 string.Empty 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(DateTime defaultDateTime)
		{
			return Create(string.Empty, defaultDateTime);
		}

		/// <summary>
		/// 엔터티를 생성한다. string형 속성은 기본 string 값으로 채우고, DateTime형 속성은 기본 DateTime 값으로 채운다.
		/// </summary>
		/// <param name="defaultString">기본 string 값</param>
		/// <param name="defaultDateTime">기본 DateTime 값</param>
		/// <returns>생성된 엔터티</returns>
		public virtual T Create(string defaultString, DateTime defaultDateTime)
		{
			T entity = new T();
			entity.Clear(defaultString, defaultDateTime);

			return entity;
		}
		#endregion

		#region Get
		/// <summary>
		/// 모든 엔터티를 반환한다.
		/// </summary>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get()
		{
			return Get<T>(null, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync() 
            => Task.Factory.StartNew(() => Get());

        /// <summary>
        /// 조건식에 맞는 엔터티들을 반환한다.
        /// </summary>
        /// <param name="where">조건식</param>
        /// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get(Expression<Func<T, bool>> where)
		{
			return Get<T>(where, null, false, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync(Expression<Func<T, bool>> where)
            => Task.Factory.StartNew(() => Get(where));

		/// <summary>
		/// 모든 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(null, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Factory.StartNew(() => Get(orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
			return Get(null, orderBy, ascending, startRowIndex, maximumRows);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Factory.StartNew(() => Get(orderBy, ascending, startRowIndex, maximumRows));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
		{
			return Get(where, orderBy, ascending, 0, int.MaxValue);
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
            => Task.Factory.StartNew(() => Get(where, orderBy, ascending));

		/// <summary>
		/// 조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
		/// <param name="startRowIndex">반환할 엔터티의 시작 인덱스</param>
		/// <param name="maximumRows">반환할 엔터티의 갯수</param>
		/// <returns>엔터티의 리스트</returns>
        public virtual List<T> Get<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
		{
            using (var context = DbContextFactory.Create())
			{
            return GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context).ToList();
			}
		}

        public virtual Task<List<T>> GetAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows)
            => Task.Factory.StartNew(() => Get(where, orderBy, ascending, startRowIndex, maximumRows));
		#endregion

		#region select
		/// <summary>
		///   모든 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, R>> select)
		{
			return Select<T, R>(null, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(select));

		/// <summary>
		///   조건식에 맞는 선택식의 결과를 반환한다.
		/// </summary>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return Select<T, R>(where, null, false, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, select));

		/// <summary>
		///   모든 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
			return Select(null, orderBy, ascending, startRowIndex, maximumRows, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(orderBy, ascending, startRowIndex, maximumRows, select));
		

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
		{
			return Select(where, orderBy, ascending, 0, int.MaxValue, select);
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, orderBy, ascending, select));

		/// <summary>
		///   조건식에 맞는 엔터티들을 정렬식에 따라 정렬한 후 선택식의 결과를 반환한다. 페이징과 프로젝션을을 지원한다. 제네릭 메서드이므로 ObjectDataSource에서는 사용할 수 없다.
		/// </summary>
		/// <typeparam name="U"> 정렬 기준이 되는 속성의 형식 </typeparam>
		/// <typeparam name="R"> 선택 형식 </typeparam>
		/// <param name="where"> 조건식 </param>
		/// <param name="orderBy"> 정렬식 </param>
		/// <param name="ascending"> true이면 오름차순, false이면 내림차순 </param>
		/// <param name="startRowIndex"> 반환할 엔터티의 시작 인덱스 </param>
		/// <param name="maximumRows"> 반환할 엔터티의 갯수 </param>
		/// <param name="select"> 선택식 </param>
		/// <returns> 엔터티의 리스트 </returns>
        public virtual List<R> Select<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
		{
            using (var context = DbContextFactory.Create())
			{
				var query = GetCore(where, orderBy, ascending, startRowIndex, maximumRows, context);
				return query.Select(select).ToList();
			}
		}

        public virtual Task<List<R>> SelectAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, Expression<Func<T, R>> select)
            => Task.Factory.StartNew(() => Select(where, orderBy, ascending, startRowIndex, maximumRows, select));

		private static IQueryable<T> GetCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, int startRowIndex, int maximumRows, KoreanStudyCafeEntities context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

			IOrderedQueryable<T> orderedQuery = null;

			if (orderBy != null)
				orderedQuery = (ascending) ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

			if (startRowIndex != 0 || maximumRows != int.MaxValue)
			{
				if (orderedQuery != null)
					orderedQuery = (IOrderedQueryable<T>)orderedQuery.Skip(startRowIndex).Take(maximumRows);
				else
					query = query.Skip(startRowIndex).Take(maximumRows);
			}

			return orderedQuery ?? query;
		}
		#endregion

		#region GetFirst / GetLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <returns>엔터티</returns>
        public virtual T GetFirst()
		{
			return GetFirst<T>(null, null);
		}

        public virtual Task<T> GetFirstAsync()
            => Task.Factory.StartNew(() => GetFirst());

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst(Expression<Func<T, bool>> where)
		{
			return GetFirst<T>(where, null);
		}

        public virtual Task<T> GetFirstAsync(Expression<Func<T, bool>> where) 
            => Task.Factory.StartNew(() => GetFirst(where));

        /// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, U>> orderBy)
		{
			return GetFirst(null, orderBy);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, U>> orderBy)
            => Task.Factory.StartNew(() => GetFirst(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
        public virtual T GetFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, true);
		}

        public virtual Task<T> GetFirstAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		    => Task.Factory.StartNew(() => GetFirst(where, orderBy));

	    private T GetFirstCore<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending)
	    {
            using (var context = DbContextFactory.Create())
			{
	        return QueryFirst(where, orderBy, ascending, context).FirstOrDefault();
			}
	    }

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <returns>엔터티</returns>
        public virtual T GetLast<U>(Expression<Func<T, U>> orderBy)
		{
			return GetLast(null, orderBy);
		}

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, U>> orderBy)
		=> Task.Factory.StartNew(() => GetLast(orderBy));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <returns>엔터티</returns>
		[ForAsync]
        public virtual T GetLast<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		{
		    return GetFirstCore(where, orderBy, false);
        }

        public virtual Task<T> GetLastAsync<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy)
		=> Task.Factory.StartNew(() => GetLast(where, orderBy));

        private static IQueryable<T> QueryFirst<U>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, bool ascending, KoreanStudyCafeEntities context)
		{
			var query = from x in context.Set<T>()
						select x;

			if (where != null)
				query = query.Where(where);

            // 마지막 행은 orderby가 반드시 지정되어 있어야 함. orderby를 지정하지 않으면 skip 메서드를 사용할 수 없기 때문.
            if (orderBy != null)
			    query = @ascending ? query.OrderBy(orderBy) : query.OrderByDescending(orderBy);

            return query;
		}
		#endregion

		#region SelectFirst / SelectLast
		/// <summary>
		/// 모든 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(null, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(select));

		/// <summary>
		/// 조건식에 맞는 엔터티 중 첫번째 엔터티를 반환한다. 엔터티의 순서는 DB에 의해 결정된다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		{
			return SelectFirst<T, R>(where, null, select);
		}

        public virtual Task<R> SelectFirstAsync<R>(Expression<Func<T, bool>> where, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(where, select));

		/// <summary>
		/// 모든 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
			return SelectFirst(null, orderBy, select);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(orderBy, select));

		/// <summary>
		/// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
		/// </summary>
		/// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
		/// <typeparam name="R">선택 형식</typeparam>
		/// <param name="where">조건식</param>
		/// <param name="orderBy">정렬식</param>
		/// <param name="select">선택식</param>
		/// <returns>엔터티</returns>
        public virtual R SelectFirst<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		{
		    return SelectFirstCore(where, orderBy, select, true);
		}

        public virtual Task<R> SelectFirstAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectFirst(where, orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 첫번째 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <param name="ascending">true이면 오름차순, false이면 내림차순</param>
        /// <returns>엔터티</returns>
        private R SelectFirstCore<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select, bool ascending)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = QueryFirst(where, orderBy, ascending, context);
			return query.Select(select).FirstOrDefault();
			}
		}

        /// <summary>
        /// 모든 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectLast(null, orderBy, select);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectLast(orderBy, select));

        /// <summary>
        /// 조건식에 맞는 엔터티를 정렬식에 따라 정렬했을 때 마지막 엔터티를 반환한다. 조건식에 맞는 엔터티가 없으면 null이 반환된다.
        /// </summary>
        /// <typeparam name="U">정렬 기준이 되는 속성의 형식</typeparam>
        /// <typeparam name="R">선택 형식</typeparam>
        /// <param name="where">조건식</param>
        /// <param name="orderBy">정렬식</param>
        /// <param name="select">선택식</param>
        /// <returns>엔터티</returns>
        public virtual R SelectLast<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
	    {
	        return SelectFirstCore(where, orderBy, select, false);
	    }

        public virtual Task<R> SelectLastAsync<U, R>(Expression<Func<T, bool>> where, Expression<Func<T, U>> orderBy, Expression<Func<T, R>> select)
		=> Task.Factory.StartNew(() => SelectLast(where, orderBy, select));
        #endregion

		#region GetCount
		/// <summary>
		/// 모든 엔터티의 갯수를 구한다.
		/// </summary>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount()
		{
			return GetCount(null);
		}

        public virtual Task<int> GetCountAsync()
		=> Task.Factory.StartNew(() => GetCount());

		/// <summary>
		/// 조건식에 맞는 엔터티의 갯수를 구한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>엔터티의 갯수</returns>
        public virtual int GetCount(Expression<Func<T, bool>> where)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Count();
			}
		}

        public virtual Task<int> GetCountAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => GetCount(where));
		#endregion

		#region Exist
		/// <summary>
		/// 조건식에 맞는 엔터티가 존재하는지 검사한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>존재 여부</returns>
        public virtual bool Exists(Expression<Func<T, bool>> where)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			return query.Any();
			}
		}

        public virtual Task<bool> ExistsAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => Exists(where));
		#endregion

		#region Write log partial methods
		/// <summary>
		/// 엔티티의 로그를 기록한다.
		/// </summary>
		/// <param name="entity">엔티티</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteSingleLog(T entity, LogType logType);

		/// <summary>
		/// 엔티티 컬렉션의 로그를 기록한다.
		/// </summary>
		/// <param name="entities">엔티티 컬렉션</param>
		/// <param name="logType">로그 타입</param>
		partial void WriteMultipleLog(IEnumerable<T> entities, LogType logType);
		#endregion

		#region Insert / Update / Delete
		/// <summary>
		/// 엔터티를 삽입한다.
		/// </summary>
		/// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual T Insert(T entity)
		{
            using (var context = DbContextFactory.Create())
			{
			MarkToInsert(context, entity);
			context.SaveChanges();

			WriteSingleLog(entity, LogType.Insert);

			return entity;
			}
		}

        public virtual Task<T> InsertAsync(T entity)
		=> Task.Factory.StartNew(() => Insert(entity));

		internal virtual void MarkToInsert(KoreanStudyCafeEntities context, T entity)
		{
			context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티 컬렉션을 삽입한다.
		/// </summary>
		/// <param name="entities">삽입할 엔터티가 포함된 컬렉션</param>
		/// <returns>삽입된 엔터티의 갯수</returns>
        public virtual int InsertMany(IEnumerable<T> entities)
		{
            using (var context = DbContextFactory.Create())
			{
			MarkToInsertMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Insert);

			return count;
			}
		}

        public virtual Task<int> InsertManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => InsertMany(entities));

		internal virtual void MarkToInsertMany(KoreanStudyCafeEntities context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Set<T>().Add(entity);
		}

		/// <summary>
		/// 엔터티를 갱신한다.
		/// </summary>
		/// <param name="entity">갱신할 엔터티</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int Update(T entity)
		{
            using (var context = DbContextFactory.Create())
			{
			MarkToUpdate(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Update);

			return count;
			}
		}

        public virtual Task<int> UpdateAsync(T entity)
		=> Task.Factory.StartNew(() => Update(entity));

		internal virtual void MarkToUpdate(KoreanStudyCafeEntities context, T entity)
		{
			context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티 컬렉션을 갱신한다.
		/// </summary>
		/// <param name="entities">갱신할 엔터티가 포함된 컬렉션</param>
		/// <returns>갱신된 엔터티의 갯수</returns>
        public virtual int UpdateMany(IEnumerable<T> entities)
		{
            using (var context = DbContextFactory.Create())
			{
            MarkToUpdateMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Update);

			return count;
			}
		}

        public virtual Task<int> UpdateManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => UpdateMany(entities));

		internal virtual void MarkToUpdateMany(KoreanStudyCafeEntities context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Modified;
		}

		/// <summary>
		/// 엔터티를 삭제한다.
		/// </summary>
		/// <param name="entity">삭제할 엔터티</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int Delete(T entity)
		{
            using (var context = DbContextFactory.Create())
			{
            MarkToDelete(context, entity);
			int count = context.SaveChanges();

			WriteSingleLog(entity, LogType.Delete);
			
			return count;
			}
		}

        public virtual Task<int> DeleteAsync(T entity)
		=> Task.Factory.StartNew(() => Delete(entity));

		internal virtual void MarkToDelete(KoreanStudyCafeEntities context, T entity)
		{
			context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 엔터티 컬렉션을 삭제한다.
		/// </summary>
		/// <param name="entities">삭제할 엔터티 컬렉션</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteMany(IEnumerable<T> entities)
		{
            using (var context = DbContextFactory.Create())
			{
			MarkToDeleteMany(context, entities);
			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
			}
		}

        public virtual Task<int> DeleteManyAsync(IEnumerable<T> entities)
		=> Task.Factory.StartNew(() => DeleteMany(entities));

		internal virtual void MarkToDeleteMany(KoreanStudyCafeEntities context, IEnumerable<T> entities)
		{
			foreach (var entity in entities)
				context.Entry(entity).State = EntityState.Deleted;
		}

		/// <summary>
		/// 조건식을 만족하는 엔터티들을 삭제한다.
		/// </summary>
		/// <param name="where">조건식</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteAll(Expression<Func<T, bool>> where)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from item in context.Set<T>()
						select item;

			if (where != null)
				query = query.Where(where);

			var entities = query.ToList();

			MarkToDeleteMany(context, entities);

			int count = context.SaveChanges();

			WriteMultipleLog(entities, LogType.Delete);

			return count;
			}
		}

        public virtual Task<int> DeleteAllAsync(Expression<Func<T, bool>> where)
		=> Task.Factory.StartNew(() => DeleteAll(where));
		#endregion
	}
	#endregion

		#region InvoiceDao
	/// <summary>
	/// Invoice 데이터 클래스
	/// </summary>
	public partial class InvoiceDao : EntityData<Invoice>
	{
		internal InvoiceDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="invoiceID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Invoice GetByKey(System.Int32 invoiceID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<Invoice>().FirstOrDefault(x =>  x.InvoiceID == invoiceID);
			}
		}

        public virtual Task<Invoice> GetByKeyAsync(System.Int32 invoiceID)
			=> Task.Factory.StartNew(() => GetByKey(invoiceID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="invoiceID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 invoiceID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Invoice>().Count(x =>  x.InvoiceID == invoiceID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 invoiceID)
		=> Task.Factory.StartNew(() => ExistsByKey(invoiceID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="invoiceID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 invoiceID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<Invoice>()
			where x.InvoiceID == invoiceID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 invoiceID)
		=> Task.Factory.StartNew(() => DeleteByKey(invoiceID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Invoice InsertIfNotExist(Invoice entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Invoice>().Count(x =>  x.InvoiceID == entity.InvoiceID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<Invoice> InsertIfNotExistAsync(Invoice entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Invoice InsertOrUpdate(Invoice entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Invoice>().Count(x =>  x.InvoiceID == entity.InvoiceID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<Invoice> InsertOrUpdateAsync(Invoice entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 UserID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="userID">외래키</param>
		/// <returns>UserID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Invoice> GetByUserID(System.Int32 userID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Invoice>().Where(x => x.UserID == userID).ToList();
			}
		}

        public virtual Task<List<Invoice>> GetByUserIDAsync(System.Int32 userID)
		=> Task.Factory.StartNew(() => GetByUserID(userID));
	}
	#endregion
	#region InvoiceLineDao
	/// <summary>
	/// InvoiceLine 데이터 클래스
	/// </summary>
	public partial class InvoiceLineDao : EntityData<InvoiceLine>
	{
		internal InvoiceLineDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="invoiceID">기본키</param>		/// <param name="itemID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual InvoiceLine GetByKey(System.Int32 invoiceID, System.Int32 itemID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<InvoiceLine>().FirstOrDefault(x =>  x.InvoiceID == invoiceID &&  x.ItemID == itemID);
			}
		}

        public virtual Task<InvoiceLine> GetByKeyAsync(System.Int32 invoiceID, System.Int32 itemID)
			=> Task.Factory.StartNew(() => GetByKey(invoiceID, itemID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="invoiceID">기본키</param>		/// <param name="itemID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 invoiceID, System.Int32 itemID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<InvoiceLine>().Count(x =>  x.InvoiceID == invoiceID &&  x.ItemID == itemID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 invoiceID, System.Int32 itemID)
		=> Task.Factory.StartNew(() => ExistsByKey(invoiceID, itemID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="invoiceID">기본키</param>		/// <param name="itemID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 invoiceID, System.Int32 itemID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<InvoiceLine>()
			where x.InvoiceID == invoiceID && x.ItemID == itemID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 invoiceID, System.Int32 itemID)
		=> Task.Factory.StartNew(() => DeleteByKey(invoiceID, itemID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual InvoiceLine InsertIfNotExist(InvoiceLine entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<InvoiceLine>().Count(x =>  x.InvoiceID == entity.InvoiceID &&  x.ItemID == entity.ItemID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<InvoiceLine> InsertIfNotExistAsync(InvoiceLine entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual InvoiceLine InsertOrUpdate(InvoiceLine entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<InvoiceLine>().Count(x =>  x.InvoiceID == entity.InvoiceID &&  x.ItemID == entity.ItemID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<InvoiceLine> InsertOrUpdateAsync(InvoiceLine entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region ItemDao
	/// <summary>
	/// Item 데이터 클래스
	/// </summary>
	public partial class ItemDao : EntityData<Item>
	{
		internal ItemDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="itemID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Item GetByKey(System.Int32 itemID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<Item>().FirstOrDefault(x =>  x.ItemID == itemID);
			}
		}

        public virtual Task<Item> GetByKeyAsync(System.Int32 itemID)
			=> Task.Factory.StartNew(() => GetByKey(itemID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="itemID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 itemID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Item>().Count(x =>  x.ItemID == itemID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 itemID)
		=> Task.Factory.StartNew(() => ExistsByKey(itemID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="itemID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 itemID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<Item>()
			where x.ItemID == itemID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 itemID)
		=> Task.Factory.StartNew(() => DeleteByKey(itemID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Item InsertIfNotExist(Item entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Item>().Count(x =>  x.ItemID == entity.ItemID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<Item> InsertIfNotExistAsync(Item entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Item InsertOrUpdate(Item entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Item>().Count(x =>  x.ItemID == entity.ItemID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<Item> InsertOrUpdateAsync(Item entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region LockerDao
	/// <summary>
	/// Locker 데이터 클래스
	/// </summary>
	public partial class LockerDao : EntityData<Locker>
	{
		internal LockerDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="lockerID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Locker GetByKey(System.Int32 lockerID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<Locker>().FirstOrDefault(x =>  x.LockerID == lockerID);
			}
		}

        public virtual Task<Locker> GetByKeyAsync(System.Int32 lockerID)
			=> Task.Factory.StartNew(() => GetByKey(lockerID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="lockerID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 lockerID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Locker>().Count(x =>  x.LockerID == lockerID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 lockerID)
		=> Task.Factory.StartNew(() => ExistsByKey(lockerID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="lockerID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 lockerID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<Locker>()
			where x.LockerID == lockerID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 lockerID)
		=> Task.Factory.StartNew(() => DeleteByKey(lockerID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Locker InsertIfNotExist(Locker entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Locker>().Count(x =>  x.LockerID == entity.LockerID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<Locker> InsertIfNotExistAsync(Locker entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Locker InsertOrUpdate(Locker entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Locker>().Count(x =>  x.LockerID == entity.LockerID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<Locker> InsertOrUpdateAsync(Locker entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region LogDao
	/// <summary>
	/// Log 데이터 클래스
	/// </summary>
	public partial class LogDao : EntityData<Log>
	{
		internal LogDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="logID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Log GetByKey(System.Int32 logID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<Log>().FirstOrDefault(x =>  x.LogID == logID);
			}
		}

        public virtual Task<Log> GetByKeyAsync(System.Int32 logID)
			=> Task.Factory.StartNew(() => GetByKey(logID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="logID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 logID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Log>().Count(x =>  x.LogID == logID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 logID)
		=> Task.Factory.StartNew(() => ExistsByKey(logID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="logID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 logID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<Log>()
			where x.LogID == logID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 logID)
		=> Task.Factory.StartNew(() => DeleteByKey(logID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Log InsertIfNotExist(Log entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Log>().Count(x =>  x.LogID == entity.LogID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<Log> InsertIfNotExistAsync(Log entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Log InsertOrUpdate(Log entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Log>().Count(x =>  x.LogID == entity.LogID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<Log> InsertOrUpdateAsync(Log entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 UserID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="userID">외래키</param>
		/// <returns>UserID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Log> GetByUserID(System.Int32 userID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Log>().Where(x => x.UserID == userID).ToList();
			}
		}

        public virtual Task<List<Log>> GetByUserIDAsync(System.Int32 userID)
		=> Task.Factory.StartNew(() => GetByUserID(userID));
	}
	#endregion
	#region ReportDao
	/// <summary>
	/// Report 데이터 클래스
	/// </summary>
	public partial class ReportDao : EntityData<Report>
	{
		internal ReportDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="reportID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Report GetByKey(System.Int32 reportID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<Report>().FirstOrDefault(x =>  x.ReportID == reportID);
			}
		}

        public virtual Task<Report> GetByKeyAsync(System.Int32 reportID)
			=> Task.Factory.StartNew(() => GetByKey(reportID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="reportID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 reportID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Report>().Count(x =>  x.ReportID == reportID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 reportID)
		=> Task.Factory.StartNew(() => ExistsByKey(reportID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="reportID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 reportID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<Report>()
			where x.ReportID == reportID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 reportID)
		=> Task.Factory.StartNew(() => DeleteByKey(reportID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Report InsertIfNotExist(Report entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Report>().Count(x =>  x.ReportID == entity.ReportID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<Report> InsertIfNotExistAsync(Report entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Report InsertOrUpdate(Report entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Report>().Count(x =>  x.ReportID == entity.ReportID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<Report> InsertOrUpdateAsync(Report entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 UserID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="userID">외래키</param>
		/// <returns>UserID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<Report> GetByUserID(System.Int32 userID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Report>().Where(x => x.UserID == userID).ToList();
			}
		}

        public virtual Task<List<Report>> GetByUserIDAsync(System.Int32 userID)
		=> Task.Factory.StartNew(() => GetByUserID(userID));
	}
	#endregion
	#region SeatDao
	/// <summary>
	/// Seat 데이터 클래스
	/// </summary>
	public partial class SeatDao : EntityData<Seat>
	{
		internal SeatDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="seatsID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual Seat GetByKey(System.Int32 seatsID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<Seat>().FirstOrDefault(x =>  x.SeatsID == seatsID);
			}
		}

        public virtual Task<Seat> GetByKeyAsync(System.Int32 seatsID)
			=> Task.Factory.StartNew(() => GetByKey(seatsID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="seatsID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 seatsID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<Seat>().Count(x =>  x.SeatsID == seatsID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 seatsID)
		=> Task.Factory.StartNew(() => ExistsByKey(seatsID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="seatsID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 seatsID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<Seat>()
			where x.SeatsID == seatsID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 seatsID)
		=> Task.Factory.StartNew(() => DeleteByKey(seatsID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual Seat InsertIfNotExist(Seat entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Seat>().Count(x =>  x.SeatsID == entity.SeatsID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<Seat> InsertIfNotExistAsync(Seat entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual Seat InsertOrUpdate(Seat entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<Seat>().Count(x =>  x.SeatsID == entity.SeatsID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<Seat> InsertOrUpdateAsync(Seat entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

		
	}
	#endregion
	#region StudyRoomDao
	/// <summary>
	/// StudyRoom 데이터 클래스
	/// </summary>
	public partial class StudyRoomDao : EntityData<StudyRoom>
	{
		internal StudyRoomDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="studyRoomID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual StudyRoom GetByKey(System.Int32 studyRoomID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<StudyRoom>().FirstOrDefault(x =>  x.StudyRoomID == studyRoomID);
			}
		}

        public virtual Task<StudyRoom> GetByKeyAsync(System.Int32 studyRoomID)
			=> Task.Factory.StartNew(() => GetByKey(studyRoomID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="studyRoomID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 studyRoomID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<StudyRoom>().Count(x =>  x.StudyRoomID == studyRoomID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 studyRoomID)
		=> Task.Factory.StartNew(() => ExistsByKey(studyRoomID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="studyRoomID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 studyRoomID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<StudyRoom>()
			where x.StudyRoomID == studyRoomID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 studyRoomID)
		=> Task.Factory.StartNew(() => DeleteByKey(studyRoomID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual StudyRoom InsertIfNotExist(StudyRoom entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<StudyRoom>().Count(x =>  x.StudyRoomID == entity.StudyRoomID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<StudyRoom> InsertIfNotExistAsync(StudyRoom entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual StudyRoom InsertOrUpdate(StudyRoom entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<StudyRoom>().Count(x =>  x.StudyRoomID == entity.StudyRoomID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<StudyRoom> InsertOrUpdateAsync(StudyRoom entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 UserID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="userID">외래키</param>
		/// <returns>UserID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<StudyRoom> GetByUserID(System.Int32? userID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<StudyRoom>().Where(x => x.UserID == userID).ToList();
			}
		}

        public virtual Task<List<StudyRoom>> GetByUserIDAsync(System.Int32? userID)
		=> Task.Factory.StartNew(() => GetByUserID(userID));
	}
	#endregion
	#region UserDao
	/// <summary>
	/// User 데이터 클래스
	/// </summary>
	public partial class UserDao : EntityData<User>
	{
		internal UserDao() {}

		
		/// <summary>
		/// 기본키가 일치하는 엔터티를 구한다.
		/// </summary>
				/// <param name="userID">기본키</param>
		/// <returns>기본키가 일치하는 엔터티</returns>
        public virtual User GetByKey(System.Int32 userID)
		{
            using (var context = DbContextFactory.Create())
			{
            return context.Set<User>().FirstOrDefault(x =>  x.UserID == userID);
			}
		}

        public virtual Task<User> GetByKeyAsync(System.Int32 userID)
			=> Task.Factory.StartNew(() => GetByKey(userID));

		/// <summary>
		/// 기본키가 일치하는 엔터티가 존재하는지 확인한다.
		/// </summary>
				/// <param name="userID">기본키</param>
		/// <returns>존재 여부</returns>
        public virtual bool ExistsByKey(System.Int32 userID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<User>().Count(x =>  x.UserID == userID) > 0;
			}
		}

        public virtual Task<bool> ExistsByKeyAsync(System.Int32 userID)
		=> Task.Factory.StartNew(() => ExistsByKey(userID));

		/// <summary>
		/// 기본키가 일치하는 엔터티를 삭제한다.
		/// </summary>
				/// <param name="userID">기본키</param>
		/// <returns>삭제된 엔터티의 갯수</returns>
        public virtual int DeleteByKey(System.Int32 userID)
		{
            using (var context = DbContextFactory.Create())
			{
			var query = from x in context.Set<User>()
			where x.UserID == userID
			select x;

			var entity = query.FirstOrDefault();

            if (entity == null)
                return 0;

			MarkToDelete(context, entity);

			return context.SaveChanges();
			}
		}

        public virtual Task<int> DeleteByKeyAsync(System.Int32 userID)
		=> Task.Factory.StartNew(() => DeleteByKey(userID));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입할 엔터티</param>
		/// <returns>삽입된 엔터티</returns>
        public virtual User InsertIfNotExist(User entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<User>().Count(x =>  x.UserID == entity.UserID) > 0)
	            return null;

	        MarkToInsert(context, entity);
	        context.SaveChanges();

	        return entity;
			}
	    }

        public virtual Task<User> InsertIfNotExistAsync(User entity)
		=> Task.Factory.StartNew(() => InsertIfNotExist(entity));

        /// <summary>
        /// 기본키가 일치하는 엔터티가 있으면 갱신하고 없으면 삽입한다.
        /// </summary>
        /// <param name="entity">삽입 혹은 갱신할 엔터티</param>
		/// <returns>삽입 혹은 갱신된 엔터티</returns>
        public virtual User InsertOrUpdate(User entity)
	    {
            using (var context = DbContextFactory.Create())
			{
	        if (context.Set<User>().Count(x =>  x.UserID == entity.UserID) > 0)
	        {
	            MarkToUpdate(context, entity);
	            context.SaveChanges();

	            return entity;

            }
            else
	        {
	            MarkToInsert(context, entity);
	            context.SaveChanges();

	            return entity;

            }
			}
	    }

        public virtual Task<User> InsertOrUpdateAsync(User entity)
		=> Task.Factory.StartNew(() => InsertOrUpdate(entity));
		

				/// <summary>
		/// 외래키 LockerID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="lockerID">외래키</param>
		/// <returns>LockerID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<User> GetByLockerID(System.Int32? lockerID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<User>().Where(x => x.LockerID == lockerID).ToList();
			}
		}

        public virtual Task<List<User>> GetByLockerIDAsync(System.Int32? lockerID)
		=> Task.Factory.StartNew(() => GetByLockerID(lockerID));
		/// <summary>
		/// 외래키 SeatsID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="seatsID">외래키</param>
		/// <returns>SeatsID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<User> GetBySeatsID(System.Int32? seatsID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<User>().Where(x => x.SeatsID == seatsID).ToList();
			}
		}

        public virtual Task<List<User>> GetBySeatsIDAsync(System.Int32? seatsID)
		=> Task.Factory.StartNew(() => GetBySeatsID(seatsID));
		/// <summary>
		/// 외래키 StudyRoomID 이(가) 일치하는 엔터티 컬렉션을 구한다.
		/// </summary>
		/// <param name="studyRoomID">외래키</param>
		/// <returns>StudyRoomID 이(가) 일치하는 엔터티 컬렉션</returns>
        public virtual List<User> GetByStudyRoomID(System.Int32? studyRoomID)
		{
            using (var context = DbContextFactory.Create())
			{
			return context.Set<User>().Where(x => x.StudyRoomID == studyRoomID).ToList();
			}
		}

        public virtual Task<List<User>> GetByStudyRoomIDAsync(System.Int32? studyRoomID)
		=> Task.Factory.StartNew(() => GetByStudyRoomID(studyRoomID));
	}
	#endregion
	#endregion

	#region Types
	/// <summary>
	/// 엔티티를 추가/수정/삭제 할 때 기록하는 로그의 종류
	/// </summary>
	internal enum LogType
	{
		/// <summary>
		/// 엔티티 삽입
		/// </summary>
		Insert,

		/// <summary>
		/// 엔티티 컬렉션 삽입
		/// </summary>
		InsertMany,

		/// <summary>
		/// 엔티티 갱신
		/// </summary>
		Update,

		/// <summary>
		/// 엔티티 컬렉션 갱신
		/// </summary>
		UpdateMany,

		/// <summary>
		/// 엔티티 삭제
		/// </summary>
		Delete,

		/// <summary>
		/// 엔티티 컬렉션 삭제
		/// </summary>
		DeleteMany
	}

	/// <summary>
	/// 데이터 액세스 레이어 클래스임을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class DataAttribute : Attribute
	{
	}

	/// <summary>
	/// 서버 캐시를 사용하도록 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class)]
	public class ForCacheAttribute : Attribute
	{
	}

	/// <summary>
	/// 서비스 메서드를 만들 것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
	public class ForServiceAttribute : Attribute
	{
	}

	/// <summary>
	/// 비동기 호출 코드를 생성할 것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	public class ForAsyncAttribute : Attribute
	{
	}

	/// <summary>
	/// 비지니스 코드를 생성하지 말것을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class ForCustomBizAttribute : Attribute
	{
	}

	/// <summary>
	/// 외래키를 조건으로 하는 Get 메서드 임을 지시
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class ByFKAttribute : Attribute
	{
	}

	/// <summary>
	/// 인증이 필요하지 않은 메서드임을 표현
	/// </summary>
	[AttributeUsage(AttributeTargets.Method)]
	public class NoAuthorizationAttribute : Attribute
	{
	}
	#endregion

	#region DaoBase
	/// <summary>
	/// Dao의 부모. Dao를 확장하는 용도로 사용한다.
	/// </summary>
	public partial class DaoBase
	{
	}
	#endregion

	#region Dao
	/// <summary>
	/// 각 엔터티 데이터 객체의 모음
	/// </summary>
	public partial class Dao : DaoBase
	{
		static Dao()
		{
						Invoice = new InvoiceDao();
			InvoiceLine = new InvoiceLineDao();
			Item = new ItemDao();
			Locker = new LockerDao();
			Log = new LogDao();
			Report = new ReportDao();
			Seat = new SeatDao();
			StudyRoom = new StudyRoomDao();
			User = new UserDao();
		}

		#region Data objects
				public static InvoiceDao Invoice { get; }
		public static InvoiceLineDao InvoiceLine { get; }
		public static ItemDao Item { get; }
		public static LockerDao Locker { get; }
		public static LogDao Log { get; }
		public static ReportDao Report { get; }
		public static SeatDao Seat { get; }
		public static StudyRoomDao StudyRoom { get; }
		public static UserDao User { get; }
		#endregion
		}
	#endregion

	#region DbContextFactory
	/// <summary>
	/// KoreanStudyCafeEntities객체 생성기
	/// </summary>
	public partial class DbContextFactory
	{
		/// <summary>
		/// MP에서 설정된 연결 문자열을 오버라이드 한다.
		/// </summary>
		/// <param name="connectionString"></param>
		static partial void GetConnectionStringCore(ref string connectionString);

	    /// <summary>
        /// KoreanStudyCafeEntities 객체가 생성되었을 때 호출된다.
        /// </summary>
        /// <param name="context">생성된 KoreanStudyCafeEntities 객체</param>
	    static partial void OnCreated(KoreanStudyCafeEntities context);

		/// <summary>
		/// 연결 문자열을 생성한다. GetConnectionStringCore 부분 메서드를 구현하지 않으면 MP에서 설정된 값을 사용한다.
		/// </summary>
		/// <returns></returns>
		public static string GetConnectionString()
		{
			string connectionString = string.Empty;

			GetConnectionStringCore(ref connectionString);

			if (string.IsNullOrEmpty(connectionString))
			return "name=KoreanStudyCafeEntities";
			else
			return connectionString;
		}

		/// <summary>
		/// KoreanStudyCafeEntities 객체를 생성한다.
		/// </summary>
		/// <returns></returns>
	    public static KoreanStudyCafeEntities Create(bool lazyLoadingEnabled = false, bool proxyCreationEnabled = false, bool autoDetectChangesEnabled = false)
	    {
	        string connectionString = GetConnectionString();

	        var context = new KoreanStudyCafeEntities(connectionString);

	        context.Configuration.LazyLoadingEnabled = lazyLoadingEnabled;
	        context.Configuration.ProxyCreationEnabled = proxyCreationEnabled;
	        context.Configuration.AutoDetectChangesEnabled = autoDetectChangesEnabled;

	        CreateCore(context);

	        return context;
	    }

	    /// <summary>
	    /// KoreanStudyCafeEntities 객체의 옵션을 설정한다.
	    /// </summary>
	    /// <param name="context">생성된 KoreanStudyCafeEntities 객체</param>
	    static partial void CreateCore(KoreanStudyCafeEntities context);
	}
	#endregion

	#region KoreanStudyCafeEntities
	public partial class KoreanStudyCafeEntities
	{
	    internal KoreanStudyCafeEntities(string nameOrConnectionString) : base(nameOrConnectionString)
	    {
	    }

	    public List<string> ValidationErrorMessages
	    {
	        get
	        {
	            return GetValidationErrors()
	            .SelectMany(x => x.ValidationErrors)
	            .Select(x => $"[{x.PropertyName}] {x.ErrorMessage}")
	            .ToList();
	        }
	    }

	    public string ValidationErrorMessage => string.Join(Environment.NewLine, ValidationErrorMessages);
	    }
	#endregion
}
